# 时间银行 - 技术架构设计文档

**文档版本：** v1.0  
**创建日期：** 2026-01-05  
**创建者：** Claude Code

---

## 1. 技术选型

### 1.1 开发语言与框架
- **语言：** Kotlin（100%）
- **UI框架：** Jetpack Compose（现代声明式UI）
- **架构模式：** MVVM + Clean Architecture
- **最低SDK：** API 26（Android 8.0）
- **目标SDK：** API 34（Android 14）

### 1.2 核心依赖库

#### Jetpack组件
```kotlin
// Compose UI
androidx.compose.ui:ui:1.5.4
androidx.compose.material3:material3:1.1.2

// 架构组件
androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0
androidx.navigation:navigation-compose:2.7.6

// 数据持久化
androidx.room:room-runtime:2.6.1
androidx.room:room-ktx:2.6.1
androidx.datastore:datastore-preferences:1.0.0

// 后台任务
androidx.work:work-runtime-ktx:2.9.0
```

#### 第三方库
```kotlin
// 依赖注入
com.google.dagger:hilt-android:2.50

// 协程
org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3

// 图表
com.github.PhilJay:MPAndroidChart:3.1.0

// 日志
com.jakewharton.timber:timber:5.0.1
```

---

## 2. 架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────┐
│              Presentation Layer             │
│  ┌─────────────────────────────────────┐   │
│  │   Jetpack Compose UI Components     │   │
│  └─────────────────────────────────────┘   │
│  ┌─────────────────────────────────────┐   │
│  │         ViewModels (State)          │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────┐
│              Domain Layer                   │
│  ┌─────────────────────────────────────┐   │
│  │          Use Cases                  │   │
│  └─────────────────────────────────────┘   │
│  ┌─────────────────────────────────────┐   │
│  │       Domain Models (Entities)      │   │
│  └─────────────────────────────────────┘   │
│  ┌─────────────────────────────────────┐   │
│  │      Repository Interfaces          │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────┐
│               Data Layer                    │
│  ┌─────────────────────────────────────┐   │
│  │    Repository Implementations       │   │
│  └─────────────────────────────────────┘   │
│  ┌───────────┬────────────┬────────────┐   │
│  │ Room DB   │ DataStore  │  System    │   │
│  │ (历史数据) │ (配置信息)  │ (Usage API)│   │
│  └───────────┴────────────┴────────────┘   │
└─────────────────────────────────────────────┘
```


### 2.2 模块划分

```
app/
├── presentation/          # 表现层
│   ├── ui/
│   │   ├── home/         # 主页
│   │   ├── classify/     # 分类管理
│   │   ├── records/      # 使用记录
│   │   ├── settings/     # 设置
│   │   ├── onboarding/   # 引导流程
│   │   └── block/        # 拦截页面
│   ├── viewmodel/        # 视图模型
│   └── navigation/       # 导航
│
├── domain/               # 领域层
│   ├── model/           # 领域模型
│   ├── usecase/         # 用例
│   └── repository/      # 仓库接口
│
├── data/                # 数据层
│   ├── repository/      # 仓库实现
│   ├── local/          # 本地数据源
│   │   ├── room/       # Room数据库
│   │   └── datastore/  # DataStore配置
│   └── system/         # 系统数据源
│       └── usage/      # UsageStatsManager封装
│
└── service/            # 服务层
    ├── monitor/        # 监控服务
    ├── accessibility/  # 无障碍服务
    └── worker/         # 后台任务
```

---

## 3. 数据模型设计

### 3.1 Room数据库表结构

#### 表1：应用分类表 (app_classification)
```kotlin
@Entity(tableName = "app_classification")
data class AppClassificationEntity(
    @PrimaryKey
    val packageName: String,        // 包名（唯一标识）
    val appName: String,             // 应用名称
    val category: AppCategory,       // 分类：POSITIVE/NEGATIVE/NONE
    val iconPath: String? = null,    // 图标路径（可选）
    val addedTime: Long,             // 添加时间戳
    val updatedTime: Long            // 更新时间戳
)

enum class AppCategory {
    POSITIVE,   // 正向应用
    NEGATIVE,   // 负向应用
    NONE        // 未分类
}
```

#### 表2：使用记录表 (usage_record)
```kotlin
@Entity(
    tableName = "usage_record",
    indices = [Index(value = ["packageName", "date"])]
)
data class UsageRecordEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val packageName: String,         // 包名
    val date: String,                // 日期 (yyyy-MM-dd)
    val startTime: Long,             // 开始时间戳
    val endTime: Long,               // 结束时间戳
    val duration: Long,              // 使用时长（秒）
    val category: AppCategory        // 分类快照
)
```


#### 表3：每日汇总表 (daily_summary)
```kotlin
@Entity(
    tableName = "daily_summary",
    indices = [Index(value = ["date"], unique = true)]
)
data class DailySummaryEntity(
    @PrimaryKey
    val date: String,                // 日期 (yyyy-MM-dd)
    val positiveDuration: Long,      // 正向应用总时长（秒）
    val negativeDuration: Long,      // 负向应用总时长（秒）
    val creditEarned: Long,          // 当日积累信用（秒）
    val creditSpent: Long,           // 当日消耗信用（秒）
    val balanceEnd: Long             // 当日结束余额（秒）
)
```

#### 表4：重置历史表 (reset_history)
```kotlin
@Entity(tableName = "reset_history")
data class ResetHistoryEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val resetTime: Long,             // 重置时间戳
    val resetType: ResetType,        // 重置类型：AUTO/MANUAL
    val weekNumber: Int,             // 周数（用于限制手动重置）
    val dataSnapshot: String         // 重置前的数据快照（JSON）
)

enum class ResetType {
    AUTO,    // 自动重置
    MANUAL   // 手动重置
}
```

### 3.2 DataStore配置项

```kotlin
object PreferenceKeys {
    val EXCHANGE_RATIO = doublePreferencesKey("exchange_ratio")         // 兑换比例
    val RESET_DAY_OF_WEEK = intPreferencesKey("reset_day_of_week")     // 重置日期
    val RESET_HOUR = intPreferencesKey("reset_hour")                   // 重置小时
    val RESET_MINUTE = intPreferencesKey("reset_minute")               // 重置分钟
    val NOTIFICATION_ENABLED = booleanPreferencesKey("notification_enabled")
    val MONITOR_SERVICE_ENABLED = booleanPreferencesKey("monitor_enabled")
    val CURRENT_BALANCE = longPreferencesKey("current_balance")        // 当前余额（秒）
    val IS_FIRST_LAUNCH = booleanPreferencesKey("is_first_launch")
    val MANUAL_RESET_COUNT = intPreferencesKey("manual_reset_count")   // 本周手动重置次数
    val LAST_RESET_WEEK = intPreferencesKey("last_reset_week")         // 上次重置周数
}
```

---

## 4. 核心功能实现

### 4.1 应用使用监控服务

#### 4.1.1 监控方案
采用 **UsageStatsManager + AccessibilityService** 双重方案：
- UsageStatsManager：主要方案，定时轮询（每10秒）
- AccessibilityService：辅助方案，实时检测应用切换

#### 4.1.2 监控服务实现
```kotlin
class AppMonitorService : Service() {
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        startForeground(NOTIFICATION_ID, createNotification())
        startMonitoring()
        return START_STICKY
    }
    
    private fun startMonitoring() {
        scope.launch {
            while (isActive) {
                checkUsageStats()
                delay(10_000) // 每10秒检查一次
            }
        }
    }
    
    private suspend fun checkUsageStats() {
        val usageStatsManager = getSystemService(Context.USAGE_STATS_SERVICE) 
            as UsageStatsManager
        val endTime = System.currentTimeMillis()
        val startTime = endTime - 10_000 // 检查最近10秒
        
        val usageStats = usageStatsManager.queryUsageStats(
            UsageStatsManager.INTERVAL_DAILY,
            startTime,
            endTime
        )
        
        // 处理使用数据
        processUsageStats(usageStats)
    }
}
```


### 4.2 拦截机制实现

#### 4.2.1 拦截策略
```kotlin
class AppBlockManager @Inject constructor(
    private val balanceRepository: BalanceRepository,
    private val classificationRepository: ClassificationRepository
) {
    suspend fun checkAndBlock(packageName: String): BlockResult {
        // 1. 检查是否为负向应用
        val category = classificationRepository.getCategory(packageName)
        if (category != AppCategory.NEGATIVE) {
            return BlockResult.Allow
        }
        
        // 2. 检查余额
        val balance = balanceRepository.getCurrentBalance()
        if (balance <= 0) {
            return BlockResult.Block(reason = "余额不足")
        }
        
        // 3. 允许使用，开始计时
        return BlockResult.AllowWithMonitor
    }
}

sealed class BlockResult {
    object Allow : BlockResult()
    data class Block(val reason: String) : BlockResult()
    object AllowWithMonitor : BlockResult()
}
```

#### 4.2.2 拦截Activity
```kotlin
@AndroidEntryPoint
class BlockActivity : ComponentActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 设置全屏并覆盖其他应用
        window.addFlags(
            WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
                or WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
                or WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
                or WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
        )
        
        setContent {
            BlockScreen(
                onDismiss = { finishAndRemoveTask() }
            )
        }
        
        // 5秒后允许返回
        lifecycleScope.launch {
            delay(5000)
            enableBackButton()
        }
    }
    
    // 禁用返回键
    override fun onBackPressed() {
        if (backButtonEnabled) {
            super.onBackPressed()
        }
    }
}
```

### 4.3 时间积累与消耗

#### 4.3.1 余额计算逻辑
```kotlin
class BalanceCalculator @Inject constructor(
    private val configRepository: ConfigRepository
) {
    /**
     * 计算正向应用使用时长对应的信用额度
     * @param duration 使用时长（秒）
     * @return 信用额度（秒）
     */
    suspend fun calculateCredit(duration: Long): Long {
        val ratio = configRepository.getExchangeRatio()
        return (duration * ratio).toLong()
    }
    
    /**
     * 扣减余额
     * @param duration 消耗时长（秒）
     * @return 是否扣减成功
     */
    suspend fun deductBalance(duration: Long): Boolean {
        val currentBalance = balanceRepository.getCurrentBalance()
        return if (currentBalance >= duration) {
            balanceRepository.updateBalance(currentBalance - duration)
            true
        } else {
            false
        }
    }
}
```


### 4.4 定期重置功能

#### 4.4.1 WorkManager定时任务
```kotlin
class ResetWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            // 执行重置逻辑
            resetAllData()
            
            // 显示通知
            showResetNotification()
            
            // 安排下次重置
            scheduleNextReset()
            
            Result.success()
        } catch (e: Exception) {
            Timber.e(e, "Reset failed")
            Result.retry()
        }
    }
    
    private suspend fun resetAllData() {
        // 1. 保存数据快照到reset_history
        saveDataSnapshot()
        
        // 2. 清空使用记录
        usageRecordDao.deleteAll()
        
        // 3. 清空每日汇总
        dailySummaryDao.deleteAll()
        
        // 4. 重置余额为0
        balanceRepository.resetBalance()
        
        // 5. 重置手动重置计数
        configRepository.resetManualResetCount()
    }
}

// 注册定时任务
class ResetScheduler @Inject constructor(
    private val workManager: WorkManager,
    private val configRepository: ConfigRepository
) {
    suspend fun schedule() {
        val config = configRepository.getResetConfig()
        
        // 计算下次重置时间
        val nextResetTime = calculateNextResetTime(
            dayOfWeek = config.dayOfWeek,
            hour = config.hour,
            minute = config.minute
        )
        
        val delay = nextResetTime - System.currentTimeMillis()
        
        val request = OneTimeWorkRequestBuilder<ResetWorker>()
            .setInitialDelay(delay, TimeUnit.MILLISECONDS)
            .build()
        
        workManager.enqueueUniqueWork(
            "reset_work",
            ExistingWorkPolicy.REPLACE,
            request
        )
    }
}
```

---

## 5. 关键技术点

### 5.1 权限处理

#### 必需权限清单
```xml
<manifest>
    <!-- 使用统计权限（需用户手动授予） -->
    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS"
        tools:ignore="ProtectedPermissions" />
    
    <!-- 前台服务 -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    
    <!-- 通知权限（Android 13+） -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    
    <!-- 系统弹窗权限 -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    
    <!-- 忽略电池优化 -->
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
</manifest>
```

#### 权限检查与引导
```kotlin
class PermissionManager @Inject constructor(
    private val context: Context
) {
    fun hasUsageStatsPermission(): Boolean {
        val appOps = context.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager
        val mode = appOps.checkOpNoThrow(
            AppOpsManager.OPSTR_GET_USAGE_STATS,
            Process.myUid(),
            context.packageName
        )
        return mode == AppOpsManager.MODE_ALLOWED
    }
    
    fun requestUsageStatsPermission(activity: Activity) {
        val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)
        activity.startActivity(intent)
    }
}
```


### 5.2 后台服务保活策略

#### 5.2.1 前台服务
```kotlin
private fun createNotification(): Notification {
    val channelId = "monitor_service"
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            channelId,
            "应用监控服务",
            NotificationManager.IMPORTANCE_LOW
        )
        notificationManager.createNotificationChannel(channel)
    }
    
    return NotificationCompat.Builder(this, channelId)
        .setContentTitle("时间银行正在运行")
        .setContentText("正在监控应用使用情况")
        .setSmallIcon(R.drawable.ic_notification)
        .setPriority(NotificationCompat.PRIORITY_LOW)
        .setOngoing(true)
        .build()
}
```

#### 5.2.2 JobScheduler辅助保活
```kotlin
class MonitorJobService : JobService() {
    override fun onStartJob(params: JobParameters?): Boolean {
        // 检查服务状态，如果被杀则重启
        if (!isServiceRunning(AppMonitorService::class.java)) {
            val intent = Intent(this, AppMonitorService::class.java)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(intent)
            } else {
                startService(intent)
            }
        }
        
        // 安排下次检查
        scheduleJob(this)
        
        jobFinished(params, false)
        return true
    }
    
    companion object {
        fun scheduleJob(context: Context) {
            val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 
                as JobScheduler
            val job = JobInfo.Builder(1001, ComponentName(context, MonitorJobService::class.java))
                .setPeriodic(15 * 60 * 1000) // 每15分钟检查一次
                .setRequiredNetworkType(JobInfo.NETWORK_TYPE_NONE)
                .setPersisted(true)
                .build()
            jobScheduler.schedule(job)
        }
    }
}
```

### 5.3 性能优化

#### 5.3.1 数据库优化
```kotlin
// 使用索引加速查询
@Entity(
    tableName = "usage_record",
    indices = [
        Index(value = ["packageName", "date"]),
        Index(value = ["date"])
    ]
)
data class UsageRecordEntity(...)

// 批量插入
@Dao
interface UsageRecordDao {
    @Transaction
    suspend fun insertBatch(records: List<UsageRecordEntity>) {
        records.forEach { insert(it) }
    }
}
```

#### 5.3.2 内存优化
```kotlin
// 使用Flow避免内存泄漏
class HomeViewModel @Inject constructor(
    private val balanceRepository: BalanceRepository
) : ViewModel() {
    
    val balance: StateFlow<Long> = balanceRepository
        .observeBalance()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = 0L
        )
}
```

#### 5.3.3 电量优化
```kotlin
// 降低轮询频率（非关键时段）
private suspend fun adaptiveMonitoring() {
    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)
    val interval = when {
        hour in 0..6 -> 60_000L  // 夜间：每分钟
        hour in 7..22 -> 10_000L // 白天：每10秒
        else -> 30_000L          // 其他：每30秒
    }
    delay(interval)
}
```


---

## 6. 安全与隐私

### 6.1 数据加密
```kotlin
// 使用SQLCipher加密数据库
dependencies {
    implementation "net.zetetic:android-database-sqlcipher:4.5.4"
}

// Room配置加密
val passphrase: ByteArray = SQLiteDatabase.getBytes("user_passphrase".toCharArray())
val factory = SupportFactory(passphrase)

Room.databaseBuilder(context, AppDatabase::class.java, "time_bank.db")
    .openHelperFactory(factory)
    .build()
```

### 6.2 权限最小化原则
- 仅请求必需权限
- 运行时动态请求
- 明确告知用户权限用途
- 权限拒绝后降级运行

### 6.3 数据本地化
- 所有数据存储在本地
- 不联网、不上传
- 不集成第三方统计SDK
- 卸载应用时清除所有数据

---

## 7. 测试策略

### 7.1 单元测试
```kotlin
// Repository测试
@Test
fun `test balance calculation`() = runTest {
    val calculator = BalanceCalculator(fakeConfigRepository)
    fakeConfigRepository.setExchangeRatio(0.8)
    
    val credit = calculator.calculateCredit(duration = 100L)
    
    assertEquals(80L, credit)
}
```

### 7.2 UI测试
```kotlin
// Compose UI测试
@Test
fun `test block screen displays correctly`() {
    composeTestRule.setContent {
        BlockScreen(onDismiss = {})
    }
    
    composeTestRule.onNodeWithText("时间余额已用完").assertIsDisplayed()
    composeTestRule.onNodeWithText("返回桌面").assertIsDisplayed()
}
```

### 7.3 集成测试
- 端到端流程测试（引导→分类→监控→拦截）
- 数据重置功能测试
- 权限授予流程测试
- 服务保活测试

---

## 8. 技术难点与解决方案

### 8.1 难点1：无法真正阻止应用启动
**问题：** Android系统限制，第三方应用无法阻止其他应用启动

**解决方案：**
1. 使用AccessibilityService实时检测应用切换
2. 检测到负向应用启动后，立即启动拦截Activity覆盖
3. 拦截Activity使用全屏+高优先级标志
4. 响应时间控制在500ms内

### 8.2 难点2：省电模式限制后台
**问题：** 国产ROM的省电策略可能杀死后台服务

**解决方案：**
1. 引导用户加入白名单
2. 使用JobScheduler定期检查并重启服务
3. 前台服务提高优先级
4. 检测服务状态，异常时发送通知提醒

### 8.3 难点3：UsageStatsManager精度问题
**问题：** 系统API统计精度约为分钟级，可能遗漏短时使用

**解决方案：**
1. 结合AccessibilityService补充实时数据
2. 使用ActivityLifecycleCallbacks监控自身应用
3. 轮询间隔设为10秒，平衡精度与性能
4. 对于<3秒的使用不计入统计


---

## 9. 构建与部署

### 9.1 构建配置
```kotlin
// build.gradle.kts (app level)
android {
    namespace = "com.timebank.app"
    compileSdk = 34
    
    defaultConfig {
        applicationId = "com.timebank.app"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0.0"
        
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
    
    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            signingConfig = signingConfigs.getByName("release")
        }
        debug {
            isMinifyEnabled = false
            applicationIdSuffix = ".debug"
        }
    }
    
    buildFeatures {
        compose = true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.8"
    }
}
```

### 9.2 混淆配置
```proguard
# Preserve Room entities
-keep class com.timebank.app.data.local.room.entity.** { *; }

# Preserve DataStore
-keep class androidx.datastore.*.** { *; }

# Preserve UsageStatsManager
-keep class android.app.usage.** { *; }
```

### 9.3 版本管理
- 使用语义化版本：`major.minor.patch`
- Git分支策略：`main`（稳定）、`develop`（开发）、`feature/*`（特性）
- Tag标记每个发布版本

---

## 10. 监控与日志

### 10.1 日志策略
```kotlin
// 使用Timber进行日志管理
class TimeBankApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        } else {
            Timber.plant(ReleaseTree())
        }
    }
}

// Release环境下的日志树（只记录Error）
class ReleaseTree : Timber.Tree() {
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        if (priority >= Log.ERROR) {
            // 记录到本地文件
            logToFile(priority, tag, message, t)
        }
    }
}
```

### 10.2 性能监控
```kotlin
// 监控关键指标
class PerformanceMonitor {
    fun trackServiceStart() {
        val startTime = System.currentTimeMillis()
        Timber.d("Service started at $startTime")
    }
    
    fun trackMemoryUsage() {
        val runtime = Runtime.getRuntime()
        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        Timber.d("Memory usage: ${usedMemory}MB")
    }
}
```

---

## 11. 技术债务与待优化项

### 11.1 已知限制
- [ ] 无法阻止系统浏览器内的网页应用
- [ ] 无法统计分屏模式下的使用时长
- [ ] 无法限制通知栏快捷启动
- [ ] Root设备可能绕过拦截

### 11.2 后续优化方向
- [ ] 引入ML模型预测用户行为
- [ ] 支持自定义拦截提示语
- [ ] 增加番茄钟模式（专注时段）
- [ ] 导出数据为可视化报告
- [ ] 支持家长远程控制（需联网）

---

## 12. 附录

### 12.1 关键API文档
- [UsageStatsManager](https://developer.android.com/reference/android/app/usage/UsageStatsManager)
- [AccessibilityService](https://developer.android.com/guide/topics/ui/accessibility/service)
- [WorkManager](https://developer.android.com/topic/libraries/architecture/workmanager)
- [Jetpack Compose](https://developer.android.com/jetpack/compose)

### 12.2 参考项目
- [Android Digital Wellbeing](https://www.android.com/digital-wellbeing/)
- [Forest App](https://www.forestapp.cc/)
- [Stay Focused](https://stayfocusd.com/)

### 12.3 文档变更历史
| 版本 | 日期 | 修改内容 | 修改人 |
|------|------|----------|--------|
| v1.0 | 2026-01-05 | 初始版本创建 | Claude Code |

---

**文档结束**

# 时间银行 - 第二次修复说明

**修复时间**: 2026-01-06
**APK 文件**: `app/build/outputs/apk/debug/app-debug.apk`
**文件大小**: 约 12MB

## 本次修复的问题

### 1. 后台监控服务开启时闪退 ✅

**问题原因**:
- Switch 的 onCheckedChange 中先调用 `viewModel.toggleMonitor(enabled)` 更新状态
- 状态更新触发重组，可能导致服务启动代码被中断
- 服务启动失败或状态不一致导致闪退

**解决方案**:
1. **调整执行顺序**: 先启动/停止服务，成功后再更新状态
2. **添加异常处理**: 使用 try-catch 捕获服务操作异常
3. **避免状态抖动**: 确保服务操作完成后才触发状态更新

**修改代码**:
```kotlin
// MainActivity.kt - SettingsScreen
Switch(
    checked = monitorEnabled,
    onCheckedChange = { enabled ->
        // 先启动或停止服务，然后再更新状态
        val intent = Intent(context, MonitorService::class.java)
        try {
            if (enabled) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    context.startForegroundService(intent)
                } else {
                    context.startService(intent)
                }
            } else {
                context.stopService(intent)
            }
            // 服务启动/停止成功后再更新状态
            viewModel.toggleMonitor(enabled)
        } catch (e: Exception) {
            Log.e("SettingsScreen", "服务操作失败: ${e.message}", e)
        }
    }
)
```

**验证方法**:
- 多次快速点击监控服务开关
- 观察是否有闪退
- 检查日志确认服务正确启动/停止

---

### 2. 应用列表偶尔显示"所有应用已分类" ✅

**问题原因**:
- 使用 `SharingStarted.WhileSubscribed(5000)` 策略
- 当页面失去焦点超过 5 秒，Flow 会停止收集
- 返回页面时数据还未重新加载，显示初始值 `emptyList()`
- 导致"所有应用已分类"误判

**解决方案**:
- 将所有 StateFlow 的 `SharingStarted.WhileSubscribed(5000)` 改为 `SharingStarted.Eagerly`
- 确保 ViewModel 中的数据流始终保持活跃
- 页面切换时数据不会被清空

**修改代码**:
```kotlin
// ClassifyViewModel.kt
private val _classifiedApps = repository.getAllApps()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.Eagerly,  // 改为 Eagerly
        initialValue = emptyList()
    )

val positiveApps: StateFlow<List<AppClassification>> = _classifiedApps
    .map { apps -> apps.filter { it.category == AppCategory.POSITIVE } }
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.Eagerly,  // 改为 Eagerly
        initialValue = emptyList()
    )

val negativeApps: StateFlow<List<AppClassification>> = _classifiedApps
    .map { apps -> apps.filter { it.category == AppCategory.NEGATIVE } }
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.Eagerly,  // 改为 Eagerly
        initialValue = emptyList()
    )

val unclassifiedApps: StateFlow<List<InstalledAppInfo>> = combine(
    _installedApps,
    _classifiedApps
) { installed, classified ->
    val classifiedPackages = classified.map { it.packageName }.toSet()
    installed.filter { it.packageName !in classifiedPackages }
}.stateIn(
    scope = viewModelScope,
    started = SharingStarted.Eagerly,  // 改为 Eagerly
    initialValue = emptyList()
)
```

**验证方法**:
- 分类一些应用
- 切换到其他 Tab
- 等待 10 秒以上
- 返回分类页面
- 检查未分类列表是否正常显示

---

### 3. 负向应用余额为 0 时拦截不生效 ✅ (最关键)

**问题原因分析**:

**原始逻辑流程**:
1. 用户打开负向应用（余额 = 0）
2. MonitorService 检测到切换应用，记录 `lastApp` 和 `lastCheckTime`
3. 等待 1 秒
4. 第 1 秒结束时，调用 `handleAppUsage(packageName, 1)`
5. 尝试 `deductBalance(1)`，因为余额是 0，扣除失败
6. 扣除失败后才启动拦截界面
7. **问题**: 用户已经使用了 1 秒负向应用才被拦截！

**解决方案**:

**1. 在切换应用时立即检查余额** (checkCurrentApp)
```kotlin
if (currentApp != lastApp) {
    // 检查是否是负向应用，如果是且余额不足则立即拦截
    val classification = appClassificationRepository.getAppByPackageName(currentApp)
    if (classification != null && classification.category == AppCategory.NEGATIVE) {
        val currentBalance = configRepository.getCurrentBalance().first()
        if (currentBalance <= 0) {
            // 立即拦截，不给任何使用时间
            launchBlockActivity(classification.appName, currentApp)
            return  // 不更新 lastApp，下次检查时继续拦截
        }
    }

    lastApp = currentApp
    lastCheckTime = currentTime
}
```

**2. 在处理使用时间时再次检查** (handleAppUsage)
```kotlin
AppCategory.NEGATIVE -> {
    // 先检查余额是否充足
    val currentBalance = configRepository.getCurrentBalance().first()
    val cost = duration

    if (currentBalance <= 0) {
        // 余额为 0，立即拦截
        launchBlockActivity(classification.appName, packageName)
        lastCheckTime = System.currentTimeMillis()  // 重置时间
    } else {
        // 尝试扣除余额
        val success = configRepository.deductBalance(cost)

        if (success) {
            // 扣除成功
            updateNotification("使用负向应用，已扣除 ${cost}秒")
        } else {
            // 扣除失败（余额变为负），拦截
            launchBlockActivity(classification.appName, packageName)
        }
    }
}
```

**新的执行流程**:
1. 用户打开负向应用（余额 = 0）
2. MonitorService 检测到切换应用
3. **立即检查**: 发现是负向应用且余额 ≤ 0
4. **立即拦截**: 弹出 BlockActivity，阻止用户使用
5. **不更新 lastApp**: 下次检查时继续拦截（防止用户关闭拦截界面后继续使用）

**验证方法**:
1. 设置一个负向应用（如：com.android.chrome）
2. 确保时间余额为 0
3. 尝试打开该负向应用
4. **预期**: 应用打开后立即（<1秒）弹出拦截界面
5. 点击"我知道了"关闭拦截界面
6. **预期**: 如果再次尝试打开，应继续被拦截

---

## 技术改进点

### 1. 服务生命周期管理
- 服务操作与状态更新解耦
- 添加异常处理机制
- 确保服务操作的原子性

### 2. 数据流管理
- 使用 `SharingStarted.Eagerly` 保持数据流活跃
- 避免页面切换导致的数据丢失
- 提升用户体验的连贯性

### 3. 拦截逻辑优化
- **双重检查机制**: 切换应用时检查 + 使用过程中检查
- **即时响应**: 0 延迟拦截，不给任何使用时间
- **持续拦截**: 关闭拦截界面后继续阻止使用

### 4. 日志完善
- 添加详细的拦截日志
- 记录余额检查结果
- 便于问题追踪和调试

---

## 测试验证清单

### 基础功能测试

#### 1. 权限管理
- [ ] 首次启动，显示"开启使用情况访问权限"提示
- [ ] 点击按钮，跳转到系统权限设置
- [ ] 开启权限后返回，自动检测并显示"开启悬浮窗权限"提示
- [ ] 开启悬浮窗权限后，显示"✅ 所有权限已开启"

#### 2. 应用分类
- [ ] 切换到"分类"Tab，显示未分类应用列表
- [ ] 搜索功能正常（按应用名称和包名）
- [ ] 点击"正向"按钮，应用添加到正向列表
- [ ] 点击"负向"按钮，应用添加到负向列表
- [ ] 切换 Tab 后返回，列表数据保持不变
- [ ] 等待 10 秒后返回，列表数据仍然正常

#### 3. 监控服务
- [ ] 切换到"设置"Tab
- [ ] 点击监控服务开关，无闪退
- [ ] 通知栏显示"时间银行正在运行"
- [ ] 多次快速开关，无闪退
- [ ] 关闭服务，通知消失

#### 4. 兑换比例
- [ ] 点击"兑换比例设置"卡片
- [ ] 滑动滑块，显示实时比例
- [ ] 点击"确认"，比例保存成功
- [ ] 返回查看，比例显示正确

### 核心功能测试

#### 5. 时间累积（正向应用）
- [ ] 设置一个正向应用
- [ ] 兑换比例设置为 1.0
- [ ] 开启监控服务
- [ ] 使用正向应用 10 秒
- [ ] 返回时间银行，余额增加约 10 秒

#### 6. 时间扣除（负向应用，余额充足）
- [ ] 设置一个负向应用
- [ ] 确保余额 > 0（如 60 秒）
- [ ] 开启监控服务
- [ ] 使用负向应用 10 秒
- [ ] 返回时间银行，余额减少约 10 秒

#### 7. **拦截功能（余额为 0）** ⚠️ 重点测试
测试步骤：
1. [ ] 设置一个负向应用（如 Chrome）
2. [ ] 将余额重置为 0
3. [ ] 开启监控服务
4. [ ] 尝试打开负向应用
5. [ ] **预期结果**:
   - 应用打开后 **立即**（<1秒）弹出拦截界面
   - 拦截界面显示"时间余额不足"
   - 显示"无法打开 [应用名称]"
   - 显示当前余额为 0
6. [ ] 点击"我知道了"关闭拦截界面
7. [ ] 再次尝试打开负向应用
8. [ ] **预期结果**: 再次被拦截（持续拦截）

#### 8. 拦截功能（余额不足）
- [ ] 设置负向应用
- [ ] 余额设置为 5 秒
- [ ] 使用负向应用
- [ ] 5 秒后应弹出拦截界面

#### 9. 边界情况测试
- [ ] 余额为 0，打开正向应用，无拦截
- [ ] 余额为 0，打开未分类应用，无拦截
- [ ] 使用正向应用获得时间，立即使用负向应用，可正常使用
- [ ] 负向应用使用过程中余额耗尽，立即拦截

### 稳定性测试

#### 10. 闪退测试
- [ ] 快速切换 Tab（主页/分类/设置）多次，无闪退
- [ ] 多次开关监控服务，无闪退
- [ ] 多次打开/关闭兑换比例对话框，无闪退
- [ ] 快速添加/删除应用分类，无闪退
- [ ] 在拦截状态下快速点击"我知道了"，无闪退

#### 11. 数据持久化
- [ ] 分类应用后关闭 App，重新打开，分类保持
- [ ] 修改兑换比例后关闭 App，重新打开，比例保持
- [ ] 获得时间后关闭 App，重新打开，余额保持

#### 12. 后台运行
- [ ] 开启监控服务后锁屏，30 秒后解锁，服务仍在运行
- [ ] 开启监控服务后切换到其他应用，服务持续监控
- [ ] 杀掉 App 进程，监控服务停止（符合预期）

---

## 日志调试

### 查看关键日志
```bash
# 查看所有相关日志
adb logcat -s MonitorService ClassifyScreen SettingsScreen

# 仅查看拦截相关日志
adb logcat | grep -E "拦截|余额不足|BlockActivity"

# 查看服务启动日志
adb logcat | grep "MonitorService"
```

### 关键日志检查点

#### 监控服务启动
```
D/SettingsScreen: 启动监控服务
D/MonitorService: 服务创建
D/MonitorService: 服务启动
```

#### 切换到负向应用（余额为 0）
```
D/MonitorService: 切换到应用: com.android.chrome
D/MonitorService: 检测到打开负向应用 Chrome，但余额为0，立即拦截
```

#### 使用负向应用（余额充足）
```
D/MonitorService: 切换到应用: com.android.chrome
D/MonitorService: 负向应用 Chrome 使用 1秒，扣除 1秒
```

#### 使用正向应用
```
D/MonitorService: 切换到应用: com.example.readingapp
D/MonitorService: 正向应用 Reading App 使用 1秒，获得 1秒
```

---

## 已知限制和注意事项

### 1. 拦截时机
- 拦截发生在应用切换后，无法在应用启动前拦截
- 用户会看到负向应用的启动画面（<1秒），然后被拦截界面覆盖
- 这是 Android 系统限制，无法在应用启动前进行拦截

### 2. 系统应用
- 无法拦截系统应用（设置、桌面等）
- 无法监控系统级操作

### 3. 电池优化
- 某些设备可能会杀掉后台服务
- 建议在系统设置中关闭"时间银行"的电池优化

### 4. 权限要求
- 必须同时拥有"使用情况访问"和"悬浮窗"权限才能正常拦截
- 用户拒绝权限后需要手动到系统设置开启

---

## 文件变更清单

### 修改的文件
1. `MainActivity.kt`
   - 修改 SettingsScreen 的 Switch 逻辑
   - 调整服务操作顺序和异常处理

2. `ClassifyViewModel.kt`
   - 将所有 `SharingStarted.WhileSubscribed(5000)` 改为 `SharingStarted.Eagerly`

3. `service/MonitorService.kt`
   - 修改 `checkCurrentApp` 函数，添加切换应用时的立即检查
   - 修改 `handleAppUsage` 函数，添加余额预检查
   - 完善拦截逻辑和日志输出

### 未修改的文件
- `BlockActivity.kt` - 拦截界面
- `AndroidManifest.xml` - 权限和组件配置
- `build.gradle.kts` - 依赖配置
- Repository 和 DAO 层

---

## 下次优化建议

1. **拦截前置**: 研究是否可以使用 AccessibilityService 实现应用启动前拦截
2. **防护增强**: 防止用户通过任务管理器强制关闭拦截界面
3. **用户引导**: 添加首次使用引导，说明如何设置和使用
4. **数据统计**: 增加每日/每周使用统计和图表
5. **通知优化**: 实时显示当前余额和消耗速度
6. **白名单**: 支持设置免监控应用（电话、短信等紧急应用）

---

**维护者**: Claude Code
**修复日期**: 2026-01-06
**版本**: v1.1 (第二次修复)
